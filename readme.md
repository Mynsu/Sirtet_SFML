Sirtet
======
예, 맞습니다.  [테트리스](https://tetris.fandom.com/wiki/Tetris_Guideline)입니다.


테트리스를 만든 이유는
----------------------
1. 3D 그래픽스 수학, 물리 연산이 없어 심사원께서 코딩 기본만 살피시기 편하고,
2. 게임과 코드 모두 심사원께 익숙하기까지 하다면 심사하는 데 피로가 덜할 것이며,
3. [**여기**](https://www.gamedev.net/articles/programming/general-and-gameplay-programming/your-first-step-to-game-development-starts-here-r2976/)[**저기**](https://www.gamedev.net/articles/programming/general-and-gameplay-programming/how-do-i-make-games-a-path-to-game-development-r892/)에서 추천한 게임들 중 유일하게 게임 플레이 로직이 머릿속에 그려지지 않았고,
4. 하고 싶지 않은 게임이더라도 끝까지 만들어 낼 수 있을지 제 자신이 궁금했기 때문입니다.

 
언어와 개발 환경은
------------------
C++ 17, Lua 5.3, 비주얼 스튜디오 2017(15.9) 그리고 윈도우즈 10(1803)입니다.


요구하는 외부 라이브러리와 운영체제의 버전은
--------------------------------------------
+ Lua 5.3.0 이상   
설치 예)
1. [**다운로드 페이지**](https://sourceforge.net/projects/luabinaries/files/5.3.5/Windows%20Libraries/Dynamic/)에서 *lua-5.3.5_Win64_dll15_lib.zip* 다운로드
2. *솔루션 디렉토리/externals/Lua-5.3/x64/*에 *include 폴더* 압축 풀기   
   *솔루션 디렉토리/externals/Lua-5.3/x64/lib/*에 *lua53.lib* 압축 풀기
3. *빌드된 Sirtet.exe와 Game.dll이 있는 디렉토리*에 *lua53.dll* 압축 풀기
+ SFML 2.5.0 이상   
설치 예)
1. [**다운로드 페이지**](https://www.sfml-dev.org/download/sfml/2.5.1/)에서 *Visual C++ 15 (2017) - 64-bit* 다운로드
2. *솔루션 디렉토리/externals/SFML-2.5/x64/*에 *include 폴더*, *lib 폴더* 압축 풀기
3. *빌드된 Server.exe가 있는 디렉토리*에 *sfml-graphics-2.dll, sfml-system-2.dll, sfml-window-2.dll* 압축 풀기   
(이 의존성은 없앨 예정입니다.)   
   *빌드된 Sirtet.exe와 Game.dll이 있는 디렉토리*에 *openal32.dll, sfml-audio-2.dll, sfml-graphics-2.dll, sfml-system-2.dll, sfml-window-2.dll* 압축 풀기
+ 윈도우즈 7 이상입니다.


빌드하시기 전에!
----------------
서버들의 IP 주소가 localhost로 설정되어 있습니다.  *staticLibs/GameLib/Common.h*에서 수정하실 수 있습니다.


제 코딩에 대해 궁금하실 만한 것들을 미리 추려봤습니다.   
------------------------------------------------------
**#깃 브랜칭 모형** **#깃 플로**
깃 플로로 버전 관리했습니다.  feature 브랜치는 develop 브랜치에 squash 병합*merge*했습니다.   
도중에 깃 플로로 갈아타면서 master 브랜치에 어울리지 않는 커밋들이 남았습니다.

**#이름 공간과 파일 디렉토리 일치**   
예로, 클래스 ::scene::inPlay::Ready를 선언, 정의한 파일은 *dlls/Game/scene/inPlay/*에 있습니다.   

**#단순한 코드 패턴** **#최소 작용의 원리**   
기능이 같은 한, 패턴이 단순하도록 코딩합니다.  패턴이 난잡한 코드는 읽고 싶지 않은데다 오류*error*까지 잦기 때문입니다.

**#헤더 파일을 포함*include*하는 순서** **#간접 포함에 기대지 않음**   
의존하는 대로 C 표준*standard* 라이브러리, C++ 표준 라이브러리, 제 3자*3rd party* 라이브러리, 직접 만든 라이브러리, 나머지 순으로 포함합니다.   
예외로, *WIN32_LEAN_AND_MEAN*을 정의한 다음 포함하면 컴파일 오류가 발생하는 헤더 파일은 가장 먼저 포함했습니다.   
또, 필요한 헤더 파일이 다른 헤더 파일을 통해 간접 포함되더라도 이에 기대지 않고 직접 포함합니다.  간접 포함하면 헤더 파일을 뺄 때마다 필요한 헤더 파일까지 송두리채 빼진 않았는지 살펴야 하기 때문입니다.   
( 각 프로젝트의 *pch.h* 등 )

**#전방 선언*forward declaration*** **#C++ 20 모듈은 아직**   
가능한 한 소스 파일에만 헤더 파일을 포함합니다.  A.hpp를 수정했는데 이것을 B.hpp가 포함한다면, B.hpp를 포함하나 A.hpp는 쓰지 않는 소스 파일까지 괜히 다시 빌드하기 때문입니다.  Pimple 패턴은 쓰지 않았습니다.   
헤더 파일에 선언된 포인터와 레퍼런스를 타입 체크해야 하더라도, 타입을 전방 선언하여 순환 참조를 예방합니다.   
( *dlls/Game/ui/NextTetriminoPanel.h*와 *PlayView.h*, *dlls/Game/scene/online/* 아래 헤더 파일들, *exes/Server/Room.h* )

**#상수를 모아둔 헤더 파일**
공유하는 상수를 모아둔 헤더 파일은 있습니다만, 공유하지 않는 상수는 각 소스 파일에 있습니다.  이유는 **#전방 선언**에서 되도록 소스 파일에만 헤더 파일을 포함하는 이유와 같습니다.   
( *staticLibs/GameLib/Common.h* )

**#인터페이스** **#접두사 *I*** **#protected** **#남용하지 않음**   
순수 가상 함수만 선언된 기반*base*·직계존속(?)*parent*·상위·추상 클래스라는 이명들 대신 자바의 인터페이스라는 이름을 차용하겠습니다.  이 저장소에서 다른 의미의 '인터페이스'는 쓰지 않습니다.   
인터페이스 이름 앞에 알파벳 대문자 *I*를 붙입니다.  이것만으로 인스턴스를 함부로 만들지 않도록 유도할 수 있습니다. 또, 문법*syntax*상 상속이지만 실은 구현*implement*임을 명시할 수 있습니다.  코드의 중의성을 없애 상속한다고 오해하지 않도록 합니다.   
인터페이스 생성자의 접근 한정자를 protected로 둔 것도 인스턴스를 함부로 만들지 않도록 유도한 것입니다.   
런타임 다형성은 메모리 간접 접근과 병합으로 잃는 성능을 고려해 필요한 경우에만 씁니다.   
( *dlls/Game/scene/* 아래 *IScene.h*들 )

**#상속** **#컴포지트*composite***   
인터페이스 구현에만 문법상 상속을 썼습니다.   
다음과 같은 이유로 상속을 지양합니다.
1. 상위 클래스와 하위 클래스가 'is-a' 관계라도 경계에서 갈팡질팡하는 속성이 있기 마련입니다.  상위 클래스에 둔 속성을 하위 클래스로(혹은 그 반대로) 옮기는 건 연쇄 효과를 감수해야 합니다.  설령 옮기지 않더라도 하위 클래스에게 필요없는 상위 클래스의 속성은 괜히 메모리와 캐시 라인을 차지합니다.  게다가 이 속성과 엮인 함수(행동*behavior*)도 노출됩니다.
2. 하위 클래스에서 멤버 변수(속성)와 멤버 함수를 선언할 때마다 상위 클래스를 살펴야 합니다.  키워드 virtual이 붙지 않은 함수를 오버라이드하려 했거나, [fragile base class](https://en.wikipedia.org/wiki/Fragile_base_class) 같은 실수를 범할 수 있기 때문입니다.
3. 'is-a' 관계에 줄곧 상속을 쓰다 보면 동시에 여러 클래스를 상속해야 할 처지에 놓입니다.  다중 상속은 문제 1과 2가 더 꼬입니다.
4. 코드를 반복하지 않기 위해 상속했다가 여전히 반복할 수 있습니다.  위 문제들은 덤입니다.
상속을 쓰지 않고는 유지보수하기 힘들다면 모르겠습니다.  다만, 다른 이유로 상속을 쓰기엔 다른 좋은 대안이 있습니다.  굳이 'is-a' 관계를 코드에 나타내고 싶다면 클래스 이름, 이름공간, 파일 디렉토리로도 할 수 있습니다.  반복되는 코드는 모듈로 떼어내면 여러 클래스에서 쓸 수 있습니다.

**#키워드 final** **#devirtualize**   
되도록 키워드 final로 상속을 금지하고 컴파일러가 devirtualize할 수 있도록 돕습니다.

**#키워드 virtual** **#키워드 override**   
앞으로도 상속하지 않을 클래스엔 키워드 virtual을 붙이지 않습니다.  괜히 vtable을 만들어 메모리를 낭비하고 함수 주소에 간접 접근할 이유가 없기 때문입니다.   
본디 키워드 override는 오작동*failure*하고 나서야 오버라이드되지 않았다는 걸 깨닫는 경우를 방지하는 역할이지만, 순수 가상 함수를 정의한 함수의 선언에도 붙여두었습니다.  다른 멤버 함수와 구별하기 위해서입니다.   
( *dlls/Game/scene/* 아래 헤더 파일들 )

**#씬*scene* 계층** **#추상화**   
<img src="https://user-images.githubusercontent.com/43042411/76703130-86641680-6712-11ea-82f0-3ba37f74c280.png"></img>
dynamic_cast를 쓰지 않아 씬 계층이 단순하고 게임 루프가 느리지 않습니다.   
클래스 ::scene::inPlay::InPlay와 ::scene::online::Online은 인터페이스 ::scene::IScene의 구현이지만 씬이 아닙니다.  굳이 씬 매니저가 처리하지 않아도 되는 것들을 맡긴 간이 씬 매니저입니다.  읽기도, 분업하기도 쉽게 추상화한 것입니다.   
( *dlls/Game/scene/* 아래 헤더 파일들 )

**#위임*delegation***   
간이 씬 매니저 ::scene::online::Online은 자신이 다루는 씬들, 즉 
서버와의 통신을 위한 스레드와 전역변수를  소스 파일 *::scene::online::Online.cpp*에만 선언/정의했습니다.  정보 은닉을 위해 클래스 ::scene::online::Online에 이것들을 다루는 함수를 두어야 했고, 자연스레 *dlls/Game/scene/online/ 아래 씬들에 ::scene::online::Online을 위임하게 되었습니다.   위임이란 걸 해도 되는진 망설여집니다.   
( *dlls/Game/scene/online/* 아래 헤더/소스 파일들 )

**#의존*dependency* 관계** **#Aggregation 관계**   
함수의 인수가 적다면 어떤 로컬 변수가 쓰이는 곳이 어딘지 쉽게 보이는 의존 관계를 선호합니다.  x64 호출 규약*calling convention*상 모두 레지스트리를 써서 성능의 하락이 없고   
*dlls/Game/scene/inPlay/Ready.h, Playing.h, GameOver.h*는 sf::Drawable 레퍼런스 타입의 멤버를 가지고 있습니다.     
그러나 
 어떤 함수는 인수를 추가하려니 오버라이드하는 순수 가상 함수와 그 구현까지 바꾸어야 했습니다.  그래서 이렇게 하지 않고 생성자를 통해 레퍼런스를 쥐어주었습니다.  Aggregation 관계는 이렇게 생겼습니다.  
( dlls/Game/scene/inPlay/InPlay.h:27, Playing.h:52, 

#RTTI
성능에 가시적인 영향이 없는 경우에 한해서만 RTTI를 썼습니다.
( dlls/Game/scene/Playing.cpp:952, dlls/Game/scene/IScene.h의 순수 가상 함수 currentScene() )

#인스턴스 카운팅
일부 클래스의 총 인스턴스 수를 제한했습니다.

#상수는 const와 constexpr

#전역 변수
정의되는 순서가 딱히 정해져있지 않고, 인자로 넘기지 않아 언제 어느 서브루틴에서 접근하는지 한눈에 보이지 않아 전역 변수를 소극적으로 쓰고 한 곳에 모아두었습니다.
유연하게 쓰기 위해 싱글턴 패턴 대신 서비스 로케이터 패턴을 썼습니다.
( staticLibs/Shared Headers Only/IServiceLocator.h, exes/Engine/ServiceLocator.h, dlls/Game/ServiceLocatorMirror.h )

#가시성 #접근 한정자
코드를 조금이라도 더 읽기 쉽도록 클래스든 구조체든 상속이든 가시성을 명시했습니다.
인터페이스의 생성자는 protected로 가시성을 제한하여 인스턴스를 명시적으로 만들지 못하고 구체concrete 클래스에서 암시적으로만 만들 수 있도록 했습니다.

#함수를 잘못 사용할 위험 차단
예를 들어, 서버로부터 받은 스테이지를 클라이언트에 적용하면서 함께 취해야할 부대 사항들을 묶어 놓은 함수 1이 있습니다.  그런데 스테이지의 레퍼런스를 넘기는 함수 2까지 있으면, 미래의 자신을 포함한 다른 사용자가 함수 1을 쓰지 않고 함수 2를 쓸 위험이 있습니다.  이런 경우는 없어야 합니다.
( dlls/Game/ui/PlayView.h )

#메소드 체이닝

#함수의 입도granularity
함수 하나가 다양한 기능을 맡지 않습니다.  일부 기능만 써야했을 때 이 함수를 다시 여러 함수로 쪼개거나 중복된 기능을 하는 함수를 또 만들어야 했기 때문입니다.

#함수 선언/정의
한 루프 안에 2번 이상 호출하거나 혹은 은닉된 정보에 캡슐화된 함수만 선언/정의됐습니다.  단지 표현식expression들을 묶어둔 함수는 없습니다.  함수는 호출 비용이 작지 않고, 인라인 함수라도 헤더 파일이 더러워집니다.

#멤버 변수의 선언 순서 #패딩
멤버 변수의 크기가 작은 것부터 위에서 아래로 선언하여 패딩을 줄였습니다.
컴파일러가 최적화할 수 있도록 초기화 리스트상 순서 역시 선언 순서와 맞추었습니다.

#멤버 변수 이름
널리 쓰이는 코딩 스탠다드대로 알파벳 소문자 m을 앞에 붙였습니다.  이는 IDE에 의존하지 않고 멤버 변수를 다른 변수로부터 쉽게 구분할 수 있게 해줍니다.
Aggregation 관계에 있거나 같은 연산을 반복하지 않도록 멤버 함수의 바깥 스코프로 빼내 수명을 늘린 것에 불과한 변수엔 이름 뒤에 특수문자 _를 붙였습니다.  이런 변수는 인스턴스의 상태인 멤버 변수와 구별해야 코드를 읽을 때 방해되지 않기 때문입니다.
명사구는 후치 형용했습니다.  이름이 기억나지 않아도 인텔리센스로 쉽게 찾을 수 있었기 때문입니다.  예를 들면, mSoftDropIntervalFrameCount와 mCoolFrameCount가 아니라 mFrameCountSoftDropInterval과 mFrameCountCool을 썼습니다.

#초기화 리스트
오작동 방지 겸 생성자에서 초기화한다면 초기화 리스트로 성능을 챙기는 것이 맞지만, init(...) 등 별도의 함수로 초기화하는 경우에도 그런 지에 대해선 의문입니다.

#Unnamed scope
Unnamed scope로 지역 변수의 수명을 필요한 만큼만 두어 에러 위험을 줄였습니다.

#늦은lazy 로컬 변수 선언
로컬 변수를 서브 루틴의 머리에 모아 두지 않았습니다.  변수를 쓰지 않고 빠져나갈 경우 변수를 만드는 데 든 싸이클만 낭비한 것이 되며, 변수가 쓰인 코드 블락과 멀어 코드를 읽는데 도움이 되지 않기 때문입니다.

#STL 원소에 임의 접근random access
std::array와 std::vector는 직접 범위 검사를 하고 연산자 []로 접근했습니다.  멤버 함수 at(...)은 내부에서 std::exception 예외 처리를 하기 때문에 느리기 때문입니다.
std::unordered_set과 std::unordered_map은 멤버 함수 find(...)로 접근하되, 있는 값인지 검사할 필요가 없는 경우에만 연산자 []로 접근했습니다.  없는 값에 연산자 []로 접근하면 값을 새로 넣기 때문입니다.  멤버 함수 at(...)을 쓰지 않은 것은 전과 같습니다.

#시간 복잡도 #실제 속도 #성능 #캐시 라인
시간 복잡도가 낮다고 실제 속도가 빠르진 않습니다.  예로, 자료 구조 중간에 있는 원소를 빼내거나 없애거나 새로 넣는 연산이 잦은 경우, 배열보다 연결 리스트를 쓰곤 합니다.  배열을 쓰면 그 원소 뒤에 있는 모든 원소들을 한 칸 씩 당기거나 밀어야하는데, 연결 리스트는 아니기 때문입니다.  하지만 이는 원소의 크기가 64 바이트 이상 클 때에 한합니다.  연결 리스트가 포인터로 메모리를 간접 접근하는 비용이 작지 않아 원소의 크기가 작은 경우엔 오히려 배열이 빠릅니다.  이 경우에도 단일singly 연결 리스트는 여전히 배열보다 빠르지만 직전 원소를 따로 다루어야 해서 코드가 길어지고, 원소를 자료 구조 가장 뒤에 넣기에 부적합합니다.
( exes/Engine/main.cpp:126, 

#문자열 리터럴
문자열 리터럴은 char[]나 std::string으로 받았습니다.  const char*로 받은 문자열 리터럴은 메모리에 남아 보안에 해가 되기 때문입니다.

#문자열을 받는 인수parameter
nullptr을 걸러낼 수 없는 char*보다 const char (&)[N]를, 문자열 리터럴이 메모리에 남는 const char (&)[N]보다 std::string을 선호했습니다.
char*이 쓰인 곳은 재귀 함수와 윈속 send 함수뿐입니다.
( staticLibs/Lib/Hash.h:11, Socket.h )

#문자열 해싱
문자열을 해싱하여 비교하는 것이 ::strcmp(...) 등으로 그대로 비교하는 것보다 유의미하게 빨랐습니다.

#인스턴스 복사 줄이기
try_emplace(...)와 emplace(std::piecewise_construct, std::forward_as_tuple(...)...)를 써서 인스턴스를 불필요하게 복사하지 않도록 했습니다.  std::vector::erase(...)가 복사 생성자를 요구하므로, 이 경우 외엔 모두 복사/이동 생성자를 명시적으로 없앴습니다.

#인스턴스 재활용
그래픽 인스턴스처럼 덩치가 크면 재활용하여 비용을 줄였습니다.
( dlls/Game/model/Tetrimino.h:133, dlls/Game/ui/NextTetriminoPanel.h:71 )

#NRVO
RVO을 위해 R-Value나 Named Return Value 중 하나만 썼을 뿐 섞어쓰지 않았습니다.

#범위 기반 for 반복문
범위 기반range-based for 반복문이 가장 빨라 선호했습니다.  마찬가지로 반복자를 쓰는 C 스타일 반복문은 오히려 가장 느려, 반복자가 필요하지 않으면 쓰지 않았습니다.  <algorithm>의 std::for_each(...)는 C 스타일 반복문보다 느려 쓰지 않았습니다.

#enum class
enum 형과 달리 스코프를 명시해야 해서 더 안전하게 코드를 작성할 수 있기 때문에 enum class 형을 썼습니다.

#키워드 inline
오버로드한 연산자와 .cpp 파일에 선언/정의된 짧은 함수에만 키워드 inline을 명시했습니다.  명시하지 않으면 컴파일러가 인라인으로 처리하지 않기 때문입니다.  이는 디스어셈블리에 call 인스트럭션 여부로 쉽게 알 수 있습니다.

#C 스타일 캐스트
static_cast<T>, reinterpret_cast<T>를 쓰지 않고 (T), (T*)처럼 C 스타일로 캐스트했습니다.  표현식expression이 지저분하지 않고 차이도 없기 때문입니다.
덧붙여 dynamic_cast<T>와 const_cast<T>는 비싸거나 필요가 없어 쓰지 않았습니다.

#switch 분기문
if 분기문보다 switch 분기문을 선호했습니다.  case들을 오름차순으로 정렬하면 컴파일러 최적화가 가능하기 때문입니다.
default case가 없는 경우 디버그 모드에선 __debugbreak()를 두어 코드에 안전함을 기하고 릴리즈 모드에선 __assume(0)으로 컴파일러가 최적화를 유도했습니다.

#키워드 friend
키워드 friend가 항상 정보 은닉을 파괴하는 것은 아닙니다.
( staticLibs/Shared Headers Only/IGame.h, dlls/Game/ServiceLocatorMirror.h와 Game.cpp )

#goto
break로 둘 이상의 스코프를 빠져나가지 못하는 경우, 읽기 쉬우면서 코드 중복을 피할 수 있는 경우에 한해서만 점프 키워드 goto를 사용했습니다.
( dlls/Game/scene/MainMenu.cpp:1000, 

#예외 처리
읽기 쉽고 빠른 if 문으로 처리하고 try-catch 블록을 쓰지 않았습니다.

#SFINAE
컴파일해야 알려주는 static_assert보다 인텔리센스가 알려주는 SFINAE 기법이 협업에 더 도움이 될 것이라 생각했습니다.
( staticLibs/Lib/ScriptLoader.h )

#정적static 라이브러리
아무리 .obj 파일을 재사용할 수 있다지만 아예 떼어놓는 것이 커플링을 막고 편하게 재사용하며 빌드 시간도 줄일 수 있는 좋은 방법입니다.  이미 링크되었기 때문에 바이너리 파일을 실행할 때 별도의 파일을 로드할 필요가 없다는 것, 출력 파일이 크다는 것은 고려 사항이 아니었습니다.

#헤더 파일만 있는 라이브러리
헤더 파일만 있어도 라이브러리로 둡니다.  그렇지 않으면 인텔리센스가 구문 분석을 못하기 때문입니다.

#.dll
Mod, 확장팩이나 심지어 다른 게임에서 재사용할 수 있는 코드는 범용성에 따라 라이브러리나 exes/Engine 프로젝트에 두고, 컨텐츠에 특화된 코드는 dlls/ 아래 프로젝트에 두었습니다.  런타임 중 .dll 파일을 해제하고 다른 .dll 파일을 로드할 수 있도록 명시적으로 링크하였습니다.
여러 프로세스에서 공유하기 위해 만든 건 아닙니다.

#씬 전환 #씬 인스턴스 생성
각 씬의 요청에 따라 씬 매니저에서 다음 씬의 인스턴스를 만듭니다.  각 씬에서 알아서 다음 씬의 인스턴스를 만들고 그 인스턴스의 주소만 씬 매니저에 넘기면 되는 방식은 개발 중 파기되었습니다.  콘솔이나 스크립트로 특정 씬을 곧바로 열기 위해 전자의 방법은 써야 했는데, 후자의 방법까지 혼용하니 코드가 복잡했기 때문입니다.
각 방법의 장단점은 다음과 같습니다. 전자의 방법은 새로운 구체concrete 클래스가 등장할 때마다 분기문을 추가해주어야 합니다만 파기된 후자의 방법은 그렇지 않습니다. 대신 파기된 후자의 방법은 다음 씬의 .h 파일이 바뀌면 이 파일을 포함한 모든 파일을 연쇄적으로 다시 컴파일해야 하고, 후자의 방법은 씬 매니저만 새로 컴파일하면 됩니다.
( dlls/Game/scene/SceneManager.h:29와 함수 setScene(...) )

#키워드 auto
타입을 명시하기엔 너무 긴데 근처 코드에서 쉽게 유추할 수 있는 경우에만 키워드 auto를 썼습니다.  미래의 자신을 포함한 다른 사람이 코드를 읽는 데 키워드 auto가 오히려 방해가 될 수 있기 때문입니다.

#uniform 초기화
uniform 초기화는 std::initializer_list를 인자로 받는 생성자가 의도와 다를 위험이 있기 때문에 쓰지 않았습니다.
( dlls/Game/model/Tetrimino.cpp:8 )  

#람다 표현식
함수의 인수parameter가 많은 것도 싫고 지역 변수들을 전역으로 옮기기도 싫었을 때와 별도의 스레드에서 돌릴 함수가 일회용일 때만, 캡쳐를 명시한 람다 표현식을 썼습니다.
( exes/QueueServer.cpp:269, Server.exe:122, dlls/Game/scene/online/Waiting.cpp:424 )


#유니버설 레퍼런스  #퍼펙트 포워딩
쓸 일이 없었습니다.

#루아 스크립트
로직은 빠르고 디버깅이 쉬워야 하므로 C++에서, 기획자와 아티스트가 부담없이 자주 바꿀 수 있어야 하는 데이터와 리소스는 루아 스크립트로 처리했습니다.

#스크립트 불러오기
스크립트에서 불러오지 못한 경우를 대비해 변수에 기본값을 주었습니다.  그리고 값을 스크립트에서 불러와 타입이나 범위를 검사한 뒤에야 변수에 덮어썼습니다.  이 과정에서 실패하면 콘솔에 출력합니다.
( dlls/Game 이하 많은 클래스에 정의된 멤버 함수 loadScript(...) )

#SFML
SFML은 SDL처럼 오픈 소스 멀티미디어 라이브러리입니다.  SDL이 C 언어로 작성된 반면 SFML은 C++로 작성되었습니다.  그렇기에 OOP의 좋은 예를 들여다볼 수 있고, 높은 수준에서 점차 낮은 수준으로 학습할 수 있었습니다.

#콘솔
[![Video Thumbnail]()](https://youtu.be/uPx0DgMIeoQ)
콘솔에 명령어와 함수를 매핑하여 런타임 중 다양한 시도를 해볼 수 있었습니다.  현재는 수정한 스크립트를 다시 불러오거나, 원하는 씬으로 이동하거나, GUI가 미완성이거나 바뀔 경우를 대비해 방을 생성하거나 들어가는 등의 명령어가 등록되어 있습니다.
( dlls/Game/SceneManager.cpp:19 )
명령에 따라 공유 데이터를 상호 배제해야 했습니다.

#로그
별도의 파일로 출력하지 않고 콘솔에 출력합니다.

#OpenMP
OpenMP가 더 느려 개발 도중 없앴습니다.

#벡터 #선형 보간 #수학
UI 애니메이션에 2차원 벡터 연산과 선형 보간이 쓰였습니다.
( dlls/Game/scene/online/InLobby.cpp:956, 1384 )
#대기열 서버 #메인 서버
서버는 단 둘, 대기열 서버와 메인 서버가 있습니다.   
중개를 위한 Redis 서버나 계정 관리를 위한 RDBMS 서버는 없습니다.   
클라이언트가 접속과 동시에 메시지를 보내더라도 서버가 이 메시지를 받지 않도록 했습니다.  이렇게 하지 않으면, 서버가 메시지를 기다리는 문제가 발생할 수 있기 때문입니다.
서버의 부하를 덜기 위해 서버가 accept를 완료한 후에야 클라이언트가 접속하도록 했습니다.  
<img src="https://user-images.githubusercontent.com/43042411/76689270-8f53da00-6677-11ea-9d8e-ad9e4df90409.png"></img>
1. 대기열 서버가 클라이언트(혹은 피어peer)로서 메인 서버에 접속합니다.   
1-1. 대기열 서버가 멈추더라도 다시 켜면 메인 서버에 접속할 수 있습니다.
2. 대기열 서버가 메인 서버에게 대기열 서버로서의 증표를 보냅니다.  메인 서버는 증표를 보낸 클라이언트를 대기열 서버로 간주합니다.
3. 클라이언트가 대기열 서버에 접속합니다.
4. 클라이언트가 대기열 서버에 임의의 해시 값을 보냅니다.  대기열 서버는 이 초대장을 보고 클라이언트가 변조되지 않았는지, 서버들과 버전이 같은지를 확인합니다.
5. 클라이언트가 시간 내에 4를 통과하고 메인 서버에도 자리가 있으면, 대기열 서버가 클라이언트와 메인 서버에 똑같은 티켓을 보냅니다.   
5-1-1. 클라이언트가 시간 내에 4를 통과했으나 메인 서버에 자리가 없으면, 대기열 서버는 클라이언트에 대기 번호를 발급하고 메인 서버에 자리가 났는지 주기적으로 물어봅니다.   
5-1-2. 메인 서버에 자리가 나면, 대기 번호 0 클라이언트에게 5를 수행합니다.   
5-2. 클라이언트가 시간 내에 4를 통과하지 못하면, 대기열 서버가 클라이언트의 접속을 끊습니다.
6. 대기열 서버가 티켓을 보낸 클라이언트와 접속을 끊습니다.
7. 클라이언트가 메인 서버에 접속합니다.
8. 클라이언트가 대기열 서버로부터 받은 티켓을 메인 서버에 에코합니다.
9. 메인 서버가 클라이언트로부터 받은 티켓이 대기열 서버로부터 받은 티켓과 일치하면, 클라이언트의 접속을 유지합니다.
9-1. 일치하지 않으면 메인 서버가 클라이언트의 접속을 끊습니다.

#IOCP #Overlapped I/O #Completion Routine
서버의 소켓 입출력에 IOCP를 썼습니다.  게임 로직은 모두 메인 스레드에서 수행토록 했습니다.

#버퍼 쓰지 않기 #소켓 옵션
대기열 서버 리스너와 리스너가 accept한 소켓들의 O/S상 버퍼를 없애 복사하지 않도록 했습니다.  버퍼가 필요할 만큼 무거운 작업을 하지 않기 때문입니다.  대신 클라이언트가 보내기/받기 버퍼를 갖습니다.

#백로그 #::AcceptEx(...)
백로그가 수용할 수 있는 접속 수만큼 ::AcceptEx(...)를 걸어두었습니다.

#접속 #Conditional Accept
클라이언트가 괜히 서버에 부하를 주지 못하도록 소켓 옵션으로 conditional accept를 설정했습니다.
같은 이유로 클라이언트가 변조, 버전 확인을 위한 해시 값을 일정 시간 내에 보내지 않으면 대기열 서버가 연결을 끊도록 했습니다.

#소켓 재활용 #DisconnectEx
정상적으로 접속을 끊은 소켓은 ::DisconnectEx(...)로 재활용했습니다.  소켓을 새것으로 교체하는 비용이 비싸기 때문이었습니다.  보내기나 받기가 실패한 소켓은 거의 모두 재활용도 실패했기 때문에 이 소켓은 새것으로 교체하도록 했습니다.  이 때 갑작스러운 교체로 생긴 문제들을 마무리하고나서 다시 ::Acceptex(...)를 걸어두었습니다.

#스트레스 테스트   
20년 3월 15일 현재, 클라이언트 100개까지는 통과했습니다.

#클라이언트 #블로킹Blocking 소켓 #윈속
클라이언트에는 블로킹 소켓을 썼습니다.  논블로킹 소켓을 쓰지 않은 이유는 멀티스레드 프로그래밍을 연습하고 싶었기 때문입니다.
개발 도중, 블로킹 소켓을 쓰는 ::send(...) 함수를 overlapped된 ::WSASend(...) 함수와 completion routine으로 교체했습니다.  스레드를 재활용하며 ::send(...) 함수를 쓰니 멀티스레드 프로그래밍 특유의 문제들이 발생했기 때문입니다.  그렇다고 ::send(...) 함수를 쓸 때마다 스레드를 새로 만들어 줄 수는 없었습니다.  스레드를 만드는 것만 해도 비용이 크고, 먼저 만든 스레드가 먼저 돈다는 보장이 없기 때문이었습니다.  받는 데에는 여전히 별도의 스레드를 재활용하며 블로킹 소켓과 ::recv(...) 함수를 썼습니다.
타임아웃을 주어 스레드를 join한 다음 소켓을 닫았습니다.  반대 순서로 소켓을 닫아 블로킹을 푼 다음 스레드를 join할 수도 있었지만, 더 graceful하게 종료했습니다.

#변조 클라이언트 감지 #해시 salt #키 스트레칭
클라이언트가 변조되진 않았는지, 버전이 서버들과 같은지를 대기열 서버가 확인토록 했습니다.  비대칭 키를 쓰지 않고, 현재 시간과 salt와 키 스트레칭으로 얻은 해시 값을 썼습니다.

**#로컬 게임 개발과 온라인 게임 개발의 비교 체험**

**#클라이언트와 서버가 공유하는 모델 애셋*asset***   
서버를 만들기 시작했을 때 클라이언트의 모델 애셋, Tetrimino와 Stage를 그대로 가져와 썼었습니다.  곧 렌더링에 쓰이는 멤버 변수/함수는 서버에게 필요치 않다는 걸 알아챘습니다.  그래서 서버의 부하를 덜기 위해 필요 없는 부위를 뺀 모델 애셋을 따로 만들어 썼습니다.   
그런데 이렇게 해보니 공유하는 코드를 따로따로 수정해줘야 했습니다.  이 과정에서 코드가 불일치하는 실수도 있었고, 디버그도 따로 해야 해 여간 불편한 게 아니었습니다.  다음엔 개발 막바지에 분리해야겠습니다.

#루프 언롤링


라이센스는 다음과 같습니다.
--------
+ [**zlib/png**](https://www.sfml-dev.org/license.php) for SFML
+ OFL for fonts