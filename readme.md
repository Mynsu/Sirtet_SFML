Sirtet
======
예, 맞습니다.  [테트리스](https://tetris.fandom.com/wiki/Tetris_Guideline)입니다.


테트리스를 만든 이유는
----------------------
1. 3D 그래픽스 수학, 물리 연산이 없어 심사원께서 코딩 기본만 살피시기 편하고,
2. 게임과 코드 모두 심사원께 익숙하기까지 하다면 심사하는 데 피로가 덜할 것이며,
3. [**여기**](https://www.gamedev.net/articles/programming/general-and-gameplay-programming/your-first-step-to-game-development-starts-here-r2976/)[**저기**](https://www.gamedev.net/articles/programming/general-and-gameplay-programming/how-do-i-make-games-a-path-to-game-development-r892/)에서 추천한 게임들 중 유일하게 게임 플레이 로직이 머릿속에 그려지지 않았고,
4. 하고 싶지 않은 게임이더라도 끝까지 만들어 낼 수 있을지 제 자신이 궁금했기 때문입니다.

 
언어와 개발 환경은
------------------
C++ 17, Lua 5.3, 비주얼 스튜디오 2017(15.9) 그리고 윈도우즈 10(1803)입니다.


요구하는 외부 라이브러리와 운영체제의 버전은
--------------------------------------------
+ Lua 5.3.0 이상   
설치 예)
1. [**다운로드 페이지**](https://sourceforge.net/projects/luabinaries/files/5.3.5/Windows%20Libraries/Dynamic/)에서 *lua-5.3.5_Win64_dll15_lib.zip* 다운로드
2. *솔루션 디렉토리/externals/Lua-5.3/x64/*에 *include 폴더* 압축 풀기   
   *솔루션 디렉토리/externals/Lua-5.3/x64/lib/*에 *lua53.lib* 압축 풀기
3. *빌드된 Sirtet.exe와 Game.dll이 있는 디렉토리*에 *lua53.dll* 압축 풀기
+ SFML 2.5.0 이상   
설치 예)
1. [**다운로드 페이지**](https://www.sfml-dev.org/download/sfml/2.5.1/)에서 *Visual C++ 15 (2017) - 64-bit* 다운로드
2. *솔루션 디렉토리/externals/SFML-2.5/x64/*에 *include 폴더*, *lib 폴더* 압축 풀기
3. *빌드된 Server.exe가 있는 디렉토리*에 *sfml-graphics-2.dll, sfml-system-2.dll, sfml-window-2.dll* 압축 풀기   
(이 의존성은 없앨 예정입니다.)   
   *빌드된 Sirtet.exe와 Game.dll이 있는 디렉토리*에 *openal32.dll, sfml-audio-2.dll, sfml-graphics-2.dll, sfml-system-2.dll, sfml-window-2.dll* 압축 풀기
+ 윈도우즈 7 이상입니다.


빌드하시기 전에!
----------------
서버들의 IP 주소가 localhost로 설정되어 있습니다.  *staticLibs/GameLib/Common.h*에서 수정하실 수 있습니다.


제 코딩에 대해 궁금하실 만한 것들을 미리 추려봤습니다.   
------------------------------------------------------
**#깃 브랜칭 모형** **#깃 플로**
깃 플로로 버전 관리했습니다.  feature 브랜치는 develop 브랜치에 squash 병합*merge*했습니다.   
도중에 깃 플로로 갈아타면서 master 브랜치에 어울리지 않는 커밋들이 남았습니다.

**#이름 공간과 파일 디렉토리 일치**   
예로, 클래스 ::scene::inPlay::Ready를 선언, 정의한 파일은 *dlls/Game/scene/inPlay/*에 있습니다.   

**#단순한 코드 패턴** **#최소 작용의 원리**   
기능이 같은 한, 패턴이 단순하도록 코딩합니다.  패턴이 난잡한 코드는 읽고 싶지 않은데다 오류*error*까지 잦기 때문입니다.

**#헤더 파일을 포함*include*하는 순서** **#간접 포함에 기대지 않음**   
의존하는 대로 C 표준*standard* 라이브러리, C++ 표준 라이브러리, 제 3자*3rd party* 라이브러리, 직접 만든 라이브러리, 나머지 순으로 포함합니다.   
예외로, *WIN32_LEAN_AND_MEAN*을 정의한 다음 포함하면 컴파일 오류가 발생하는 헤더 파일은 가장 먼저 포함했습니다.   
또, 필요한 헤더 파일이 다른 헤더 파일을 통해 간접 포함되더라도 이에 기대지 않고 직접 포함합니다.  간접 포함하면 헤더 파일을 뺄 때마다 필요한 헤더 파일까지 송두리채 빼진 않았는지 살펴야 하기 때문입니다.   
( 각 프로젝트의 *pch.h* 등 )

**#전방 선언*forward declaration*** **#C++ 20 모듈은 아직**   
가능한 한 소스 파일에만 헤더 파일을 포함합니다.  A.hpp를 수정했는데 이것을 B.hpp가 포함한다면, B.hpp를 포함하나 A.hpp는 쓰지 않는 소스 파일까지 괜히 다시 빌드하기 때문입니다.  Pimple 패턴은 쓰지 않았습니다.   
헤더 파일에 선언된 포인터와 레퍼런스를 타입 체크해야 하더라도, 타입을 전방 선언하여 순환 참조를 예방합니다.   
( *dlls/Game/ui/NextTetriminoPanel.h*와 *PlayView.h*, *dlls/Game/scene/online/* 아래 헤더 파일들, *exes/Server/Room.h* )

**#상수를 모아둔 헤더 파일**
공유하는 상수를 모아둔 헤더 파일은 있습니다만, 공유하지 않는 상수는 각 소스 파일에 있습니다.  이유는 **#전방 선언**에서 되도록 소스 파일에만 헤더 파일을 포함하는 이유와 같습니다.   
( *staticLibs/GameLib/Common.h* )

**#인터페이스** **#접두사 *I*** **#protected** **#남용하지 않음**   
순수 가상 함수만 선언된 기반*base*·직계존속(?)*parent*·상위·추상 클래스라는 이명들 대신 자바의 인터페이스라는 이름을 차용하겠습니다.  이 저장소에서 다른 의미의 '인터페이스'는 쓰지 않습니다.   
인터페이스 이름 앞에 알파벳 대문자 *I*를 붙입니다.  이것만으로 인스턴스를 함부로 만들지 않도록 유도할 수 있습니다. 또, 문법*syntax*상 상속이지만 실은 구현*implement*임을 명시할 수 있습니다.  코드의 중의성을 없애 상속한다고 오해하지 않도록 합니다.   
인터페이스 생성자의 접근 한정자를 protected로 둔 것도 인스턴스를 함부로 만들지 않도록 유도한 것입니다.   
런타임 다형성은 메모리 간접 접근과 병합으로 잃는 성능을 고려해 필요한 경우에만 씁니다.   
( *dlls/Game/scene/* 아래 *IScene.h*들 )

**#상속** **#컴포지트*composite***   
인터페이스 구현에만 문법상 상속을 썼습니다.   
다음과 같은 이유로 상속을 지양합니다.
1. 상위 클래스와 하위 클래스가 'is-a' 관계라도 경계에서 갈팡질팡하는 속성이 있기 마련입니다.  상위 클래스에 둔 속성을 하위 클래스로(혹은 그 반대로) 옮기는 건 연쇄 효과를 감수해야 합니다.  설령 옮기지 않더라도 하위 클래스에게 필요없는 상위 클래스의 속성은 괜히 메모리와 캐시 라인을 차지합니다.  게다가 이 속성과 엮인 함수(행동*behavior*)도 노출됩니다.
2. 하위 클래스에서 멤버 변수(속성)와 멤버 함수를 선언할 때마다 상위 클래스를 살펴야 합니다.  키워드 virtual이 붙지 않은 함수를 오버라이드하려 했거나, [fragile base class](https://en.wikipedia.org/wiki/Fragile_base_class) 같은 실수를 범할 수 있기 때문입니다.
3. 'is-a' 관계에 줄곧 상속을 쓰다 보면 동시에 여러 클래스를 상속해야 할 처지에 놓입니다.  다중 상속은 문제 1과 2가 더 꼬입니다.
4. 코드를 반복하지 않기 위해 상속했다가 여전히 반복할 수 있습니다.  위 문제들은 덤입니다.
상속을 쓰지 않고는 유지보수하기 힘들다면 모르겠습니다.  다만, 다른 이유로 상속을 쓰기엔 다른 좋은 대안이 있습니다.  굳이 'is-a' 관계를 코드에 나타내고 싶다면 클래스 이름, 이름공간, 파일 디렉토리로도 할 수 있습니다.  반복되는 코드는 모듈로 떼어내면 여러 클래스에서 쓸 수 있습니다.

**#키워드 final** **#devirtualize**   
상속을 지양하므로 키워드 final을 애용합니다.   
이것은 컴파일러가 devirtualize할 수 있도록 돕기도 합니다.  이때, 키워드 virtual을 붙여 컴파일러를 방해하지 않습니다.

**#키워드 virtual**   
언젠가 상속될 수도 있는 클래스라도 미리 키워드 virtual을 붙여놓지 않습니다.  괜히 vtable을 만들어 메모리를 낭비하고 함수 주소에 간접 접근할 이유가 없기 때문입니다.  키워드 virtual을 붙이지 않아 생기는 실수는 키워드 override로 예방합니다.

**#키워드 override**   
상위 클래스의 멤버 함수를 재정의하려는 멤버 함수엔 항상 키워드 override를 붙입니다.  이것으로 키워드 virtual이 붙지 않은 멤버 함수를 재정의하려고 하거나, 비슷한 시그니처 때문에 재정의했다고 착각하는 실수를 막을 수 있습니다.  일관된 코드를 위해 그리고 다른 멤버 함수와 구별하기 위해, 순수 가상 함수를 정의한 멤버 함수에도 키워드 override를 붙입니다.   
( *dlls/Game/scene/* 아래 헤더 파일들 )

**#씬*scene* 계층** **#추상화**   
<img src="https://user-images.githubusercontent.com/43042411/76703130-86641680-6712-11ea-82f0-3ba37f74c280.png"></img>
dynamic_cast를 쓰지 않아 씬 계층이 단순하고 게임 루프가 느리지 않습니다.   
클래스 ::scene::inPlay::InPlay와 ::scene::online::Online은 인터페이스 ::scene::IScene의 구현이지만 씬이 아닙니다.  굳이 씬 매니저가 처리하지 않아도 되는 것들을 맡긴 간이 씬 매니저입니다.  읽기도, 분업하기도 쉽게 추상화한 것입니다.   
( *dlls/Game/scene/* 아래 헤더 파일들 )

**#위임*delegation***   
간이 씬 매니저 ::scene::online::Online은 자신이 다루는 씬들에 위임됩니다.  서버와 통신하기 위한 스레드와 전역변수를 소스 파일 *::scene::online::Online.cpp*에만 선언, 정의했기 때문입니다.  일종의 정보 은닉입니다.   
별개로, 인스턴스를 쓰는 도중 지우거나 재귀 호출할 우려가 있으므로 자신을 통째로 위임하지 않도록 고칠 예정입니다.   
( *dlls/Game/scene/online/* 아래 헤더 파일들과 *Online.cpp* )

**#의존*dependency* 관계** **#x64 호출 규약** **#Aggregation 관계**   
의존 관계를 선호합니다.  즉, 인스턴스를 그때그때 레퍼런스 매개변수로 넘기려고 합니다.  레퍼런스를 쥐고 있게 하거나 전역 포인터로 넘기는 것은 선호하지 않습니다.  디버그할 때 어떤 인스턴스가 어디에 쓰이는지 쉽게 보이기 때문입니다.  x64 호출 규약*calling convention*이 매개변수 4개까진 레지스트리에 넘기는 덕분에 성능도 얻습니다.   
하지만 Aggregation 관계가 두 곳 있습니다.  여러 씬들이 인스턴스를 공유하려는데 인터페이스를 수정하고 싶지는 않아서,
콘솔로 호출하는 함수들을 컨테이너 하나에 담기 위해 타입을 통일하다 이 관계가 맺어졌습니다.   
( *dlls/Game/scene/inPlay/* 아래 헤더 파일들에 선언된 sf::Drawable 멤버 레퍼런스, exes/Engine/Command.h )

**#RTTI**
굳이 쓰지 않아도 되고 성능 손해까지 있지만 연습 삼아 써봤습니다.
( *dlls/Game/scene/Playing.cpp:973* 키워드 typeid, *dlls/Game/scene/IScene.h:34* 함수 currentScene() )

**#인스턴스 카운팅**
일부 클래스의 총 인스턴스 수를 제한했습니다.
( 일부 헤더 파일의 static bool IsInstantiated )

**#상수는 const와 constexpr** **#매크로 상수 없음**   
매크로 상수를 쓰지 않습니다.  디버그 창에 뜨지 않기 때문입니다.  그래서 const나 constexpr로 상수를 만듭니다.  주소에 접근하지만 않으면 메모리에 상주하지도 않습니다.

**#전역 변수**   
**#의존 관계**에서 설명했듯 전역 변수를 소극적으로 씁니다.  전역 변수를 모아 관리할 수 있고 의존성 주입이 되는 서비스 로케이터 패턴을 씁니다.  싱글턴 패턴은 쓰지 않습니다.   
( *exes/Engine/ServiceLocator.h, dlls/Game/ServiceLocatorMirror.h* )

**#가시성** **#접근 한정자**   
구조체라도 public을 명시하고 클래스라도 private을 명시합니다.  볼 때마다 가시성이 뭔지 생각하느라 피로가 쌓이기 때문입니다.   
**#protected**도 참고해주십시오.

**#정보 은닉** **#함수 이름** **#추상화**   
멤버 변수의 비const 레퍼런스를 넘기는 getter 함수는 setter 함수기도 하다는 것을 주의해야 합니다.  기존 setter 함수가 한 줄 짜리라면 쉽게 눈에 띄지만, 그렇지 않다면 멤버 변수 하나에 대해 setter 함수가 여럿일 수 있기 때문입니다.   
함수 이름은 어떻게 동작하는지가 아니라 결국 하고자 하는 게 뭔지를 나타냅니다.  함수를 쓰는 사람은 어떻게 동작하는지 신경쓰고 싶어하지 않습니다.  어떻게 동작하는지 알려야 한다면 주석을 답니다.   
( *dlls/Game/ui/PlayView.h* )

**#함수의 입도*granularity***   
함수 하나가 여러 기능을 맡지 않습니다.  한 기능을 써야할 때 그제서야 이 함수를 여러 함수로 쪼개면 연쇄 효과를 감수해야 합니다.  쪼개지 않더라도 기능이 중복된 함수를 만들어야 합니다.

**#함수≠코드 번들**   
단지 코드들을 묶어 놓기 위해 함수로 만들지 않습니다.  반환 값과 매개변수가 없는 함수를 호출하더라도 여전히 돌아갈 서브루틴을 적고 새 서브루틴에 접근하고 스택 프레임을 찍는 비용이 듭니다.  인라인 함수는 호출 비용이 없으나 헤더 파일이 더러워집니다.  코드들을 묶는 건 unnamed scope나 주석으로 충분합니다.  

**#멤버 변수의 선언 순서** **#패딩** **#초기화 리스트*initializer list***   
멤버 변수의 크기가 작은 것부터 선언하여 패딩을 줄였습니다.  아무리 대용량 메모리가 보급되었다지만 캐시 라인까지 낭비할 수는 없습니다.   
초기화 리스트 순서 역시 선언 순서와 맞추어 컴파일러가 최적화하도록 돕습니다.

**#멤버 변수 이름** **#접두사** **#접미사**
멤버 변수 이름 앞에 알파벳 소문자 m을 붙입니다.  어디에서 멤버 변수의 값이 바뀌는지 IDE에 의존하는 것보다 더 쉽게 알 수 있습니다.   
연산 반복을 피하기 위해 값을 임시 저장하는 멤버 변수나 레퍼런스 이름 뒤엔 특수문자 _도 붙입니다.  인스턴스의 상태인 다른 멤버 변수와 구분하여 코드를 읽기 쉽습니다.   

**#unnamed scope**   
일부 지역 변수는 unnamed scope로 수명을 한정해 오류 위험을 줄였습니다.  컴파일러가 알아서 해주지만 명시했습니다.  단, unnamed scope를 썼다가 인스턴스를 만들고 지우기를 반복하게 된다면 쓰지 않습니다.  인스턴스를 만드는 것도 비용이 있기 때문입니다.

**#늦은*lazy* 지역 변수 선언**   
지역 변수를 서브루틴의 머리에 모아 두지 않습니다.  예외 처리처럼 서브루틴 중간에 빠져나가면, 지역 변수를 만드는 비용만 축내기 때문입니다.  또, 지역 변수가 쓰이는 곳과 거리가 멀어 코드를 읽는데도 좋지 않기 때문입니다.

**#STL 원소에 임의 접근*random access***   
std::array와 std::vector의 원소는 연산자 []로 접근합니다.  인덱스를 초과했는지는 손수 검사합니다.  내부에서 검사해주는 멤버 함수 at(...)은 쓰지 않습니다.  std::exception으로 예외 처리해서 느리기 때문입니다.  std::vector는 힙 할당과 병합 때문에 성능 손해가 있어 std::array를 선호합니다.   
std::unordered_map의 원소는 멤버 함수 find(...)로 접근합니다.  연산자 []는 되도록 쓰지 않습니다.  없는 키를 넣으면 값을 만들어, 키가 있는 줄 착각할 수 있기 때문입니다.  값을 만들기 위해 기본 생성자를 강요하는 것도 단점입니다.  멤버 함수 at(...)을 쓰지 않는 이유는 전과 같습니다.

**#배열** **#std::array**   
내부에서만 쓰지 않고 인자로 넘기는 배열은 C 스타일로 만들지 않고 std::array로 만듭니다.  크기와 차원을 전달하기 쉽기 때문입니다.

**#시간 복잡도** **#실제 빠르기**   
자료 구조 중간에 있는 원소를 빼내거나 새로 넣는 경우가 잦다고 연결 리스트를 쓰지는 않습니다.  원소의 크기가 64 바이트 미만이면 SIMD를 쓰지 않아도 배열이 더 빠릅니다.  이 경우에도 단일*singly* 연결 리스트는 배열보다 빠르지만, 직전 원소를 따로 다뤄야 해 코드가 길고 자료 구조 가장 뒤에 원소를 넣기엔 부적합합니다.   

**#문자열 리터럴**
문자열 리터럴은 (const/constexpr) char[]나 std::string으로 받습니다.  const char*로 받은 문자열 리터럴은 메모리에 남아 보안에 해가 되기 때문입니다.

**#문자열을 받는 인수parameter**
nullptr을 걸러낼 수 없는 char*보다 const char (&)[N]를, 문자열 리터럴이 메모리에 남을 수 있는 const char (&)[N]보다 std::string을 선호합니다.  char*이 쓰인 곳은 재귀 함수와 윈속 send 함수뿐입니다.
( *staticLibs/Lib/Hash.h:11, Socket.h* )

**#문자열 해싱** **#보안** **#성능**   
보안과 성능을 위해 문자열을 해싱해 다룹니다.  문자열을 해싱해 비교하면 ::strcmp(...) 등으로 비교하는 것보다 유의미하게 빠릅니다.

**#인스턴스 복사 줄이기**   
try_emplace(...)와 emplace(std::piecewise_construct, std::forward_as_tuple(...)...)를 써서 인스턴스를 불필요하게 복사하지 않도록 합니다.

**#복사 생성자** **#이동 생성자** **#키워드 delete**   
되도록 건들지 않습니다만, 복사/이동 생성자가 의도와 다르게 작동할 우려가 되면 없애둡니다. 

**#인스턴스 재활용**   
그래픽 인스턴스처럼 덩치가 크거나 소켓처럼 핸들을 얻는데 부하가 있는 경우, 가능한 한 기존 인스턴스를 재활용합니다.   
( *dlls/Game/model/Tetrimino.h:118, dlls/Game/ui/NextTetriminoPanel.h:71* )

**#NRVO**  
RVO을 위해 R-Value만 반환하거나 Named Return Value만 반환할 뿐, 혼용하지 않습니다.

**#범위 기반*range-based* for 반복문**   
범위 기반 for 반복문을 선호합니다.  C 스타일 for 반복문보다 빠르기 때문입니다.   
<algorithm>의 std::for_each(...)는 C 스타일 for 반복문보다 느려, 반복자*iterator*를 쓰는 for 반복문은 가장 느려 쓰지 않습니다.  범위 기반 for 반복문도 내부에서 반복자를 쓰는데도 불구하고 그 차이가 큽니다.

**#enum class**
enum class 타입은 enum 타입과 달리 스코프*scope*를 명시하도록 강요하므로 코드가 더 안전합니다.   

**#키워드 inline**   
오버로드한 연산자와 .cpp 파일에 선언, 정의된 짧은 함수를 인라인으로 삼으려면 키워드 inline을 명시해야 합니다.  프로젝트 설정만으로는 인라인으로 삼을 수 없습니다.  인라인 여부는 디스어셈블리에서 call 인스트럭션이 있는지 아닌지를 보면 쉽게 알 수 있습니다.

**#C 스타일 캐스트**   
static_cast<T>, reinterpret_cast<T>를 쓰지 않고 (T), (T*)처럼 C 스타일로 캐스트합니다.  차이도 없고 읽고 쓰기도 쉽기 때문입니다.

**#switch 분기문**   
if 분기문보다 switch 분기문을 선호합니다.  case들을 오름차순으로 정렬하면 컴파일러가 최적화하기 때문입니다.   
default case가 있으면 안 되는 경우, 디버그 모드에선 __debugbreak()(x86의 __asm { int 3 })를 두어 오류를 잡습니다.  릴리즈 모드에선 __assume(0)을 두어 컴파일러가 최적화하도록 합니다.

**#SFINAE** **#std::enable_if**   
SFINAE는 원하는 템플릿을 추론하도록 컴파일러를 유도하는 기술입니다.  그래서 템플릿이 특정 타입만 받도록 강제할 수 있습니다.  게다가 인텔리센스 덕분에 컴파일하지 않고도 추론이 잘 되는지를 알 수 있습니다.  static_assert보다 더 효과가 좋습니다.   
( *staticLibs/Lib/ScriptLoader.h* )

**#키워드 friend**   
키워드 friend가 항상 정보 은닉을 깨는 건 아닙니다.   
( *staticLibs/GameLib/IGame.h, dlls/Game/ServiceLocatorMirror.h*와 *Game.cpp* )

**#goto**   
두 겹 이상 스코프를 빠져나가는 경우에만 goto를 허용합니다.  키워드 break로는 이것을 할 수 없는데다 goto 문이 읽기도 쉽기 때문입니다.   
( *dlls/Game/scene/MainMenu.cpp:999* )

**#예외 처리**   
예외 처리는 빠르고 읽기 쉬운 if 문으로 처리합니다.  try-catch 블록은 쓰지 않습니다.

**#빌드 타임 링킹 라이브러리**   
바뀐 코드가 없는 .obj 파일은 다시 컴파일하지 않아도 됩니다.  그렇지만 앞으로도 코드가 바뀔 일이 없는 모듈은 라이브러리로 떼어놓는 것이 커플링을 막고 여러 프로젝트에서 재사용하기 훨씬 좋습니다.   
런타임 링킹 방법들과 달리 빌드 타임 링킹 방법이 갖는 장점은 바이너리 파일을 프로세스로 올릴 때 라이브러리가 필요하지 않다는 것입니다.  대신 똑같은 라이브러리가 여러 프로세스마다 있는 셈이라 메모리 낭비일 수 있습니다.  출력 파일 .lib가 런타임 링킹 방법들보다 훨씬 클 수도 있습니다.
( *staticLibs/Lib/* 프로젝트 )

**#헤더 파일만 있는 라이브러리**   
헤더 파일만 공유하거나 재사용하더라도 포함만 하지 않고 라이브러리에 둡니다.  인텔리센스가 구문 분석을 못하기 때문입니다.
( *staticLibs/GameLib/* 프로젝트 )

**#런타임 링킹 라이브러리** **#.dll**   
엔진처럼 여러 Mod, 확장팩, 다른 게임에서 재사용하는 바이너리는 실행 파일로 만들고, 특정 Mod, 확장팩, 게임 컨텐츠를 담은 바이너리는 런타임 링킹 라이브러리, 즉 .dll 파일로 만듭니다.  보통 빌드 타임 링킹 방법과 달리 라이브러리를 공유하려고 쓰지만, 적어도 이 게임은 그렇지 않습니다.   
.lib 파일의 도움을 받으면 많은 제 3자 라이브러리처럼 편하게 쓸 수 있습니다.  이 게임을 만들기 시작했을 때도 이 방법이었습니다.  그러나 연습을 위해 .lib 파일의 도움을 받지 않고, 런타임 중 해제하고 로드할 수 있는 지금의 방법으로 옮겼습니다.
( *dlls/Game/* 프로젝트 )

**#씬 생성** **#의존성 주입 vs. 일원화**   
처음엔 다음 씬을 생성하는 걸 각 씬에게만 맡겼습니다.  그런데 콘솔이나 스크립트로 원하는 씬을 열려면 씬 매니저도 씬을 생성할 수 있어야 했습니다.  두 방법을 혼용하다보니 코드가 난잡해 결국 씬 매니저에게 일임했습니다.  대신 씬을 추가할 때마다 분기문으로 관리하게 되었습니다.   
( *dlls/Game/scene/SceneManager.h*의 멤버 함수 update(...)와 함수 setScene(...) )

**#키워드 auto** **#structured binding** **#C++ 1y**   
단지 타입이 길다고 키워드 auto를 쓰지 않습니다.  근처 코드에서 쉽게 유추할 수 있기까지 해야 씁니다.  키워드 auto 때문에 코드를 읽는 데 방해가 될 수 있기 때문입니다.  예를 들어, 반복자, structured binding, utf-8 문자열 리터럴을 받을 때 씁니다.

**#uniform 초기화** **#C++ 1y**   
Uniform 초기화는 매개변수가 std::initializer_list인 생성자에 따라 의도치 않은 동작을 하기 때문에 쓰지 않습니다.  ( )가 중의적이라면 =로 초기화합니다.  이 코드에서 { }로 초기화한 것은 집합*aggregation* 초기화입니다.

**#람다 표현식**
많은 지역 변수들을 함수에 넘기기엔 매개변수가 너무 많고, 한 구조체로 묶어 넘기기엔 억지고, 전역으로 옮기는 것은 지양하므로(**#의존 관계** 참고), 람다 표현식을 썼습니다.  다른 스레드에서 돌릴 함수가 일회용일 때도 람다 표현식을 썼습니다.   캡쳐는 항상 명시합니다.
( *exes/QueueServer.cpp:269, Server.exe:122, dlls/Game/scene/online/Waiting.cpp:424* )


#유니버설 레퍼런스  #퍼펙트 포워딩
쓸 일이 없었습니다.

#루아 스크립트
로직은 빠르고 디버깅이 쉬워야 하므로 C++에서, 기획자와 아티스트가 부담없이 자주 바꿀 수 있어야 하는 데이터와 리소스는 루아 스크립트로 처리했습니다.

#스크립트 불러오기
스크립트에서 불러오지 못한 경우를 대비해 변수에 기본값을 주었습니다.  그리고 값을 스크립트에서 불러와 타입이나 범위를 검사한 뒤에야 변수에 덮어썼습니다.  이 과정에서 실패하면 콘솔에 출력합니다.
( dlls/Game 이하 많은 클래스에 정의된 멤버 함수 loadScript(...) )

#SFML
SFML은 SDL처럼 오픈 소스 멀티미디어 라이브러리입니다.  SDL이 C 언어로 작성된 반면 SFML은 C++로 작성되었습니다.  그렇기에 OOP의 좋은 예를 들여다볼 수 있고, 높은 수준에서 점차 낮은 수준으로 학습할 수 있었습니다.

#콘솔
[![Video Thumbnail]()](https://youtu.be/uPx0DgMIeoQ)
콘솔에 명령어와 함수를 매핑하여 런타임 중 다양한 시도를 해볼 수 있었습니다.  현재는 수정한 스크립트를 다시 불러오거나, 원하는 씬으로 이동하거나, GUI가 미완성이거나 바뀔 경우를 대비해 방을 생성하거나 들어가는 등의 명령어가 등록되어 있습니다.
( dlls/Game/SceneManager.cpp:19 )
명령에 따라 공유 데이터를 상호 배제해야 했습니다.

#로그
별도의 파일로 출력하지 않고 콘솔에 출력합니다.

#OpenMP
OpenMP가 더 느려 개발 도중 없앴습니다.

#벡터 #선형 보간 #수학
UI 애니메이션에 2차원 벡터 연산과 선형 보간이 쓰였습니다.
( dlls/Game/scene/online/InLobby.cpp:956, 1384 )

#대기열 서버 #메인 서버
서버는 단 둘, 대기열 서버와 메인 서버가 있습니다.   
중개를 위한 Redis 서버나 계정 관리를 위한 RDBMS 서버는 없습니다.   
클라이언트가 접속과 동시에 메시지를 보내더라도 서버가 이 메시지를 받지 않도록 했습니다.  이렇게 하지 않으면, 서버가 메시지를 기다리는 문제가 발생할 수 있기 때문입니다.
서버의 부하를 덜기 위해 서버가 accept를 완료한 후에야 클라이언트가 접속하도록 했습니다.  
<img src="https://user-images.githubusercontent.com/43042411/76689270-8f53da00-6677-11ea-9d8e-ad9e4df90409.png"></img>
1. 대기열 서버가 클라이언트(혹은 피어peer)로서 메인 서버에 접속합니다.   
1-1. 대기열 서버가 멈추더라도 다시 켜면 메인 서버에 접속할 수 있습니다.
2. 대기열 서버가 메인 서버에게 대기열 서버로서의 증표를 보냅니다.  메인 서버는 증표를 보낸 클라이언트를 대기열 서버로 간주합니다.
3. 클라이언트가 대기열 서버에 접속합니다.
4. 클라이언트가 대기열 서버에 임의의 해시 값을 보냅니다.  대기열 서버는 이 초대장을 보고 클라이언트가 변조되지 않았는지, 서버들과 버전이 같은지를 확인합니다.
5. 클라이언트가 시간 내에 4를 통과하고 메인 서버에도 자리가 있으면, 대기열 서버가 클라이언트와 메인 서버에 똑같은 티켓을 보냅니다.   
5-1-1. 클라이언트가 시간 내에 4를 통과했으나 메인 서버에 자리가 없으면, 대기열 서버는 클라이언트에 대기 번호를 발급하고 메인 서버에 자리가 났는지 주기적으로 물어봅니다.   
5-1-2. 메인 서버에 자리가 나면, 대기 번호 0 클라이언트에게 5를 수행합니다.   
5-2. 클라이언트가 시간 내에 4를 통과하지 못하면, 대기열 서버가 클라이언트의 접속을 끊습니다.
6. 대기열 서버가 티켓을 보낸 클라이언트와 접속을 끊습니다.
7. 클라이언트가 메인 서버에 접속합니다.
8. 클라이언트가 대기열 서버로부터 받은 티켓을 메인 서버에 에코합니다.
9. 메인 서버가 클라이언트로부터 받은 티켓이 대기열 서버로부터 받은 티켓과 일치하면, 클라이언트의 접속을 유지합니다.
9-1. 일치하지 않으면 메인 서버가 클라이언트의 접속을 끊습니다.

#IOCP #Overlapped I/O #Completion Routine
서버의 소켓 입출력에 IOCP를 썼습니다.  게임 로직은 모두 메인 스레드에서 수행토록 했습니다.

#버퍼 쓰지 않기 #소켓 옵션
대기열 서버 리스너와 리스너가 accept한 소켓들의 O/S상 버퍼를 없애 복사하지 않도록 했습니다.  버퍼가 필요할 만큼 무거운 작업을 하지 않기 때문입니다.  대신 클라이언트가 보내기/받기 버퍼를 갖습니다.

#백로그 #::AcceptEx(...)
백로그가 수용할 수 있는 접속 수만큼 ::AcceptEx(...)를 걸어두었습니다.

#접속 #Conditional Accept
클라이언트가 괜히 서버에 부하를 주지 못하도록 소켓 옵션으로 conditional accept를 설정했습니다.
같은 이유로 클라이언트가 변조, 버전 확인을 위한 해시 값을 일정 시간 내에 보내지 않으면 대기열 서버가 연결을 끊도록 했습니다.

#소켓 재활용 #DisconnectEx
정상적으로 접속을 끊은 소켓은 ::DisconnectEx(...)로 재활용했습니다.  소켓을 새것으로 교체하는 비용이 비싸기 때문이었습니다.  보내기나 받기가 실패한 소켓은 거의 모두 재활용도 실패했기 때문에 이 소켓은 새것으로 교체하도록 했습니다.  이 때 갑작스러운 교체로 생긴 문제들을 마무리하고나서 다시 ::Acceptex(...)를 걸어두었습니다.

#스트레스 테스트   
20년 3월 15일 현재, 클라이언트 100개까지는 통과했습니다.

#클라이언트 #블로킹Blocking 소켓 #윈속
클라이언트에는 블로킹 소켓을 썼습니다.  논블로킹 소켓을 쓰지 않은 이유는 멀티스레드 프로그래밍을 연습하고 싶었기 때문입니다.
개발 도중, 블로킹 소켓을 쓰는 ::send(...) 함수를 overlapped된 ::WSASend(...) 함수와 completion routine으로 교체했습니다.  스레드를 재활용하며 ::send(...) 함수를 쓰니 멀티스레드 프로그래밍 특유의 문제들이 발생했기 때문입니다.  그렇다고 ::send(...) 함수를 쓸 때마다 스레드를 새로 만들어 줄 수는 없었습니다.  스레드를 만드는 것만 해도 비용이 크고, 먼저 만든 스레드가 먼저 돈다는 보장이 없기 때문이었습니다.  받는 데에는 여전히 별도의 스레드를 재활용하며 블로킹 소켓과 ::recv(...) 함수를 썼습니다.
타임아웃을 주어 스레드를 join한 다음 소켓을 닫았습니다.  반대 순서로 소켓을 닫아 블로킹을 푼 다음 스레드를 join할 수도 있었지만, 더 graceful하게 종료했습니다.

#변조 클라이언트 감지 #해시 salt #키 스트레칭
클라이언트가 변조되진 않았는지, 버전이 서버들과 같은지를 대기열 서버가 확인토록 했습니다.  비대칭 키를 쓰지 않고, 현재 시간과 salt와 키 스트레칭으로 얻은 해시 값을 썼습니다.

**#로컬 게임 개발과 온라인 게임 개발의 비교 체험**

**#클라이언트와 서버가 공유하는 모델 애셋*asset***   
서버를 만들기 시작했을 때 클라이언트의 모델 애셋, Tetrimino와 Stage를 그대로 가져와 썼었습니다.  곧 렌더링에 쓰이는 멤버 변수/함수는 서버에게 필요치 않다는 걸 알아챘습니다.  그래서 서버의 부하를 덜기 위해 필요 없는 부위를 뺀 모델 애셋을 따로 만들어 썼습니다.   
그런데 이렇게 해보니 공유하는 코드를 따로따로 수정해줘야 했습니다.  이 과정에서 코드가 불일치하는 실수도 있었고, 디버그도 따로 해야 해 여간 불편한 게 아니었습니다.  다음엔 개발 막바지에 분리해야겠습니다.

#루프 언롤링

#레퍼런스, by-value

#메소드 체이닝

#최적화

#템플릿 특수화

#디버그 모드에서 릴리즈 모드로

#포인터와 레퍼런스


라이센스는 다음과 같습니다.
--------
+ [**zlib/png**](https://www.sfml-dev.org/license.php) for SFML
+ OFL for fonts